name: Send FULL UX Metrics to Grafana

on:
  workflow_dispatch:
  push:
    branches: [ main ]
  schedule:
    # Corre una vez al d√≠a para tener series continuas
    - cron: "0 3 * * *"

jobs:
  export-ux-metrics:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Run UX Metrics collector (headless, multi-flows)
        env:
          FRONT_URL: "https://tukuntech-front.netlify.app"
          E2E_USER: ${{ secrets.E2E_USER }}
          E2E_PASS: ${{ secrets.E2E_PASS }}
        run: |
          set -euo pipefail
          mkdir -p metrics
          npm i playwright@1.48.2
          npx playwright install chromium

          cat > collect_ux_metrics.mjs <<'JS'
          import { chromium } from 'playwright';
          import fs from 'node:fs';

          const FRONT_URL = process.env.FRONT_URL;
          const USER = process.env.E2E_USER;
          const PASS = process.env.E2E_PASS;
          const METRICS_PATH = 'metrics/frontend_ux.json';

          async function clickFirstIfExists(page, selectors = []) {
            for (const sel of selectors) {
              try {
                const locator = page.locator(sel);
                const count = await locator.count();
                if (count > 0) {
                  console.log(`   ‚Ü≥ clicking selector: ${sel}`);
                  await locator.first().click();
                  await page.waitForTimeout(1000);
                  return true;
                }
              } catch (err) {
                console.warn(`      ‚ö†Ô∏è error trying selector ${sel}:`, err.message ?? err);
              }
            }
            console.log("   ‚Ü≥ no clickable selector found (non-blocking).");
            return false;
          }

          async function scrollPage(page) {
            try {
              console.log("   ‚Ü≥ scrolling page...");
              await page.mouse.wheel(0, 600);
              await page.waitForTimeout(500);
              await page.mouse.wheel(0, 600);
              await page.waitForTimeout(500);
              await page.mouse.wheel(0, -900);
            } catch (err) {
              console.warn("   ‚ö†Ô∏è error scrolling page:", err.message ?? err);
            }
          }

          async function navigateAndExercise(page, config) {
            const {
              path,
              waitSelectors = [],
              clickSelectors = [],
              pauseMs = 2500,
              retries = 2
            } = config;

            console.log("‚û°Ô∏è", path);
            let success = false;

            for (let attempt = 1; attempt <= retries; attempt++) {
              try {
                console.log(`   ‚Ü≥ attempt ${attempt}`);
                await page.goto(`${FRONT_URL}${path}`, {
                  waitUntil: 'domcontentloaded',
                  timeout: 60000,
                });

                // Espera a elementos caracter√≠sticos de la vista
                for (const sel of waitSelectors) {
                  try {
                    await page.waitForSelector(sel, { timeout: 15000 });
                    console.log(`   ‚Ü≥ found selector: ${sel}`);
                    break;
                  } catch {
                    console.warn(`   ‚ö†Ô∏è selector "${sel}" not found on ${path} (non-blocking).`);
                  }
                }

                await scrollPage(page);

                // Clics "tipo" en la pantalla
                if (clickSelectors.length > 0) {
                  await clickFirstIfExists(page, clickSelectors);
                } else {
                  await clickFirstIfExists(page, [
                    '[data-ux="primary-action"]',
                    'button[type="submit"]',
                    'button.btn-primary',
                    'table tbody tr',
                  ]);
                }

                await page.waitForTimeout(pauseMs);
                success = true;
                break;
              } catch (err) {
                console.warn(
                  `   ‚ö†Ô∏è error navigating/exercising ${path} (attempt ${attempt}):`,
                  err.message ?? err
                );
              }
            }

            if (!success) {
              console.warn(`   ‚ö†Ô∏è giving up on ${path} after ${retries} attempts (non-blocking).`);
            }
          }

          async function main() {
            let browser;
            const collected = [];

            const writeMetricsFile = () => {
              try {
                fs.writeFileSync(METRICS_PATH, JSON.stringify(collected, null, 2));
                console.log(`‚úÖ UX metrics file written with ${collected.length} events (best-effort).`);
              } catch (err) {
                console.error("‚ùå Failed to write UX metrics file:", err);
              }
            };

            if (!FRONT_URL || !USER || !PASS) {
              console.warn("‚ö†Ô∏è FRONT_URL, E2E_USER or E2E_PASS not set. Skipping UX navigation, writing empty metrics.");
              writeMetricsFile();
              return;
            }

            try {
              browser = await chromium.launch({ headless: true });
              const page = await browser.newPage({ viewport: { width: 1366, height: 800 } });

              page.setDefaultNavigationTimeout(60000);
              page.setDefaultTimeout(30000);

              console.log("üåê Opening front:", FRONT_URL);
              await page.goto(`${FRONT_URL}/auth/login`, {
                waitUntil: 'domcontentloaded',
                timeout: 60000,
              });

              await page.fill('input[name="username"], input[formcontrolname="username"]', USER);
              await page.fill('input[name="password"], input[formcontrolname="password"]', PASS);

              await Promise.all([
                page.click('button[type="submit"]'),
                page.waitForURL('**/dashboard/**', { timeout: 60000 }),
              ]);

              console.log("‚úÖ Logged in, exercising app flows...");

              // Flujos basados en tus rutas reales
              const flows = [
                // Dashboard ‚Äúroot‚Äù (redirige seg√∫n rol)
                {
                  path: '/dashboard',
                  waitSelectors: ['app-sidebar', 'router-outlet'],
                },
                // Dashboard paciente
                {
                  path: '/dashboard/patient',
                  waitSelectors: ['app-sidebar', 'app-dashboard-patient, app-dashboardpatientcomponent'],
                  clickSelectors: [
                    '.alerts__item',
                    'section.card',
                  ],
                },
                // Signos vitales
                {
                  path: '/vital-signs',
                  waitSelectors: ['app-patient-vital-signs'],
                },
                // Historia cl√≠nica
                {
                  path: '/history',
                  waitSelectors: ['app-patient-history'],
                  clickSelectors: [
                    '.alert-box',
                    '.metric',
                  ],
                },
                // Soporte
                {
                  path: '/support',
                  waitSelectors: ['app-support-patient'],
                },
                // Suscripci√≥n (si existe en el men√∫)
                {
                  path: '/subscription',
                  waitSelectors: ['app-subscription, [class*="subscription"]'],
                },
              ];

              for (const flow of flows) {
                await navigateAndExercise(page, flow);
              }

              // Extraer la cola UX al final de toda la sesi√≥n
              try {
                const data = await page.evaluate(() => {
                  const q = (window as any).__UXQ;
                  if (!q || !Array.isArray(q)) {
                    return [];
                  }
                  return q;
                });

                console.log(`‚ÑπÔ∏è window.__UXQ length: ${data.length}`);
                collected.push(...data);
              } catch (err) {
                console.warn("‚ö†Ô∏è Failed to read window.__UXQ, using empty list:", err.message ?? err);
              }

            } catch (err) {
              console.error("‚ö†Ô∏è UX metrics collection encountered an error (non-blocking):", err);
            } finally {
              writeMetricsFile();

              if (browser) {
                try {
                  await browser.close();
                } catch (err) {
                  console.warn("‚ö†Ô∏è Error closing browser:", err.message ?? err);
                }
              }
            }
          }

          main().catch(err => {
            console.error("‚ö†Ô∏è Unhandled error in main (non-blocking):", err);
          });
          JS

          node collect_ux_metrics.mjs || echo "‚ö†Ô∏è UX metrics script failed but this is non-blocking."

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install OTLP exporter
        run: |
          set -euo pipefail
          pip install \
            opentelemetry-sdk==1.38.0 \
            opentelemetry-api==1.38.0 \
            opentelemetry-exporter-otlp==1.38.0

      - name: Send UX metrics to Grafana Cloud (full attrs, best-effort)
        env:
          OTLP_ENDPOINT: ${{ secrets.GRAFANA_OTLP_ENDPOINT }}
          GRAFANA_ID: ${{ secrets.GRAFANA_INSTANCE_ID }}
          GRAFANA_TOKEN: ${{ secrets.GRAFANA_API_TOKEN }}
        run: |
          set -euo pipefail
          python - << 'PY'
          import os, json, time, base64, pathlib, sys

          metrics_path = pathlib.Path("metrics/frontend_ux.json")

          if not metrics_path.exists():
            print("‚ö†Ô∏è UX metrics file not found, skipping export (non-blocking).")
            sys.exit(0)

          try:
            raw = metrics_path.read_text(encoding="utf-8")
            items = json.loads(raw or "[]")
          except Exception as e:
            print(f"‚ö†Ô∏è Could not parse UX metrics JSON: {e}. Skipping export (non-blocking).")
            sys.exit(0)

          if not isinstance(items, list) or not items:
            print("‚ÑπÔ∏è UX metrics list is empty or invalid, nothing to export.")
            sys.exit(0)

          otlp_endpoint = os.environ.get("OTLP_ENDPOINT", "").strip()
          grafana_id = os.environ.get("GRAFANA_ID", "").strip()
          grafana_token = os.environ.get("GRAFANA_TOKEN", "").strip()

          if not otlp_endpoint or not grafana_id or not grafana_token:
            print("‚ö†Ô∏è OTLP/Grafana configuration missing. Skipping export (non-blocking).")
            sys.exit(0)

          try:
            from opentelemetry.sdk.resources import Resource
            from opentelemetry.sdk.metrics import MeterProvider
            from opentelemetry.sdk.metrics.export import PeriodicExportingMetricReader
            from opentelemetry.exporter.otlp.proto.http.metric_exporter import OTLPMetricExporter
          except Exception as e:
            print(f"‚ö†Ô∏è Failed to import OpenTelemetry libraries: {e}. Skipping export (non-blocking).")
            sys.exit(0)

          try:
            endpoint = otlp_endpoint.rstrip("/") + "/v1/metrics"
            basic = base64.b64encode(f"{grafana_id}:{grafana_token}".encode("ascii")).decode("ascii")

            exporter = OTLPMetricExporter(
                endpoint=endpoint,
                headers=(("Authorization", f"Basic {basic}"),),
            )

            resource = Resource.create({
                "service.name": "frontend-ux",
                "service.namespace": "ci"
            })

            reader = PeriodicExportingMetricReader(exporter, export_interval_millis=1000)
            provider = MeterProvider(resource=resource, metric_readers=[reader])
            meter = provider.get_meter("ux-metrics")

            # Un s√≥lo histograma, diferenciando por atributos (metric, route, conn_type, etc.)
            hist = meter.create_histogram("frontend_ux_ms")

            count = 0
            for e in items:
              try:
                dur = float(e.get("value", 0) or 0.0)
              except Exception:
                dur = 0.0

              # Atributos ricos: lo que viene en e["attrs"] + ruta + nombre de m√©trica
              attrs = {}
              base_attrs = e.get("attrs") or {}

              # Solo nos quedamos con tipos b√°sicos soportados por OTEL
              for k, v in base_attrs.items():
                if isinstance(v, (str, bool, int, float)) or v is None:
                  attrs[k] = "" if v is None else v

              attrs.setdefault("metric", e.get("metric") or "")
              attrs.setdefault("route", e.get("route") or "")
              attrs.setdefault("source", "github-actions")

              try:
                hist.record(dur, attributes=attrs)
                count += 1
              except Exception as rec_err:
                print(f"‚ö†Ô∏è Failed to record UX metric {e}: {rec_err}")

            time.sleep(3)
            print(f"‚úÖ Best-effort: sent {count} UX events to Grafana.")
          except Exception as e:
            print(f"‚ö†Ô∏è Failed sending UX metrics to Grafana (non-blocking): {e}")
            sys.exit(0)
          PY

      - name: Upload artifact (for debug)
        uses: actions/upload-artifact@v4
        with:
          name: frontend_ux
          path: metrics/frontend_ux.json
